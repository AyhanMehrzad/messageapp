{"version":3,"file":"static/js/640.49f42bfb.chunk.js","mappings":"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","sources":["../node_modules/framer-motion/dist/es/utils/use-composed-ref.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/utils.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs","components/MessageInput.js"],"sourcesContent":["import * as React from 'react';\n\n/**\n * Taken from https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx\n */\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef(ref, value) {\n    if (typeof ref === \"function\") {\n        return ref(value);\n    }\n    else if (ref !== null && ref !== undefined) {\n        ref.current = value;\n    }\n}\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs(...refs) {\n    return (node) => {\n        let hasCleanup = false;\n        const cleanups = refs.map((ref) => {\n            const cleanup = setRef(ref, node);\n            if (!hasCleanup && typeof cleanup === \"function\") {\n                hasCleanup = true;\n            }\n            return cleanup;\n        });\n        // React <19 will log an error to the console if a callback ref returns a\n        // value. We don't use ref cleanups internally so this will only happen if a\n        // user's ref callback returns a value, which we only expect if they are\n        // using the cleanup functionality added in React 19.\n        if (hasCleanup) {\n            return () => {\n                for (let i = 0; i < cleanups.length; i++) {\n                    const cleanup = cleanups[i];\n                    if (typeof cleanup === \"function\") {\n                        cleanup();\n                    }\n                    else {\n                        setRef(refs[i], null);\n                    }\n                }\n            };\n        }\n    };\n}\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs(...refs) {\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { useComposedRefs };\n","\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport { isHTMLElement } from 'motion-dom';\nimport * as React from 'react';\nimport { useId, useRef, useContext, useInsertionEffect } from 'react';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { useComposedRefs } from '../../utils/use-composed-ref.mjs';\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component {\n    getSnapshotBeforeUpdate(prevProps) {\n        const element = this.props.childRef.current;\n        if (element && prevProps.isPresent && !this.props.isPresent) {\n            const parent = element.offsetParent;\n            const parentWidth = isHTMLElement(parent)\n                ? parent.offsetWidth || 0\n                : 0;\n            const size = this.props.sizeRef.current;\n            size.height = element.offsetHeight || 0;\n            size.width = element.offsetWidth || 0;\n            size.top = element.offsetTop;\n            size.left = element.offsetLeft;\n            size.right = parentWidth - size.width - size.left;\n        }\n        return null;\n    }\n    /**\n     * Required with getSnapshotBeforeUpdate to stop React complaining.\n     */\n    componentDidUpdate() { }\n    render() {\n        return this.props.children;\n    }\n}\nfunction PopChild({ children, isPresent, anchorX, root }) {\n    const id = useId();\n    const ref = useRef(null);\n    const size = useRef({\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        right: 0,\n    });\n    const { nonce } = useContext(MotionConfigContext);\n    const composedRef = useComposedRefs(ref, children?.ref);\n    /**\n     * We create and inject a style block so we can apply this explicit\n     * sizing in a non-destructive manner by just deleting the style block.\n     *\n     * We can't apply size via render as the measurement happens\n     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n     * styles directly on the DOM node, we might be overwriting\n     * styles set via the style prop.\n     */\n    useInsertionEffect(() => {\n        const { width, height, top, left, right } = size.current;\n        if (isPresent || !ref.current || !width || !height)\n            return;\n        const x = anchorX === \"left\" ? `left: ${left}` : `right: ${right}`;\n        ref.current.dataset.motionPopId = id;\n        const style = document.createElement(\"style\");\n        if (nonce)\n            style.nonce = nonce;\n        const parent = root ?? document.head;\n        parent.appendChild(style);\n        if (style.sheet) {\n            style.sheet.insertRule(`\n          [data-motion-pop-id=\"${id}\"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            ${x}px !important;\n            top: ${top}px !important;\n          }\n        `);\n        }\n        return () => {\n            if (parent.contains(style)) {\n                parent.removeChild(style);\n            }\n        };\n    }, [isPresent]);\n    return (jsx(PopChildMeasure, { isPresent: isPresent, childRef: ref, sizeRef: size, children: React.cloneElement(children, { ref: composedRef }) }));\n}\n\nexport { PopChild };\n","\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport * as React from 'react';\nimport { useId, useMemo } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { PopChild } from './PopChild.mjs';\n\nconst PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, root }) => {\n    const presenceChildren = useConstant(newChildrenMap);\n    const id = useId();\n    let isReusedContext = true;\n    let context = useMemo(() => {\n        isReusedContext = false;\n        return {\n            id,\n            initial,\n            isPresent,\n            custom,\n            onExitComplete: (childId) => {\n                presenceChildren.set(childId, true);\n                for (const isComplete of presenceChildren.values()) {\n                    if (!isComplete)\n                        return; // can stop searching when any is incomplete\n                }\n                onExitComplete && onExitComplete();\n            },\n            register: (childId) => {\n                presenceChildren.set(childId, false);\n                return () => presenceChildren.delete(childId);\n            },\n        };\n    }, [isPresent, presenceChildren, onExitComplete]);\n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    if (presenceAffectsLayout && isReusedContext) {\n        context = { ...context };\n    }\n    useMemo(() => {\n        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));\n    }, [isPresent]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(() => {\n        !isPresent &&\n            !presenceChildren.size &&\n            onExitComplete &&\n            onExitComplete();\n    }, [isPresent]);\n    if (mode === \"popLayout\") {\n        children = (jsx(PopChild, { isPresent: isPresent, anchorX: anchorX, root: root, children: children }));\n    }\n    return (jsx(PresenceContext.Provider, { value: context, children: children }));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\nexport { PresenceChild };\n","import { Children, isValidElement } from 'react';\n\nconst getChildKey = (child) => child.key || \"\";\nfunction onlyElements(children) {\n    const filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, (child) => {\n        if (isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n\nexport { getChildKey, onlyElements };\n","\"use client\";\nimport { jsx, Fragment } from 'react/jsx-runtime';\nimport { useMemo, useRef, useState, useContext } from 'react';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { usePresence } from './use-presence.mjs';\nimport { onlyElements, getChildKey } from './utils.mjs';\n\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nconst AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = \"sync\", propagate = false, anchorX = \"left\", root }) => {\n    const [isParentPresent, safeToRemove] = usePresence(propagate);\n    /**\n     * Filter any children that aren't ReactElements. We can only track components\n     * between renders with a props.key.\n     */\n    const presentChildren = useMemo(() => onlyElements(children), [children]);\n    /**\n     * Track the keys of the currently rendered children. This is used to\n     * determine which children are exiting.\n     */\n    const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);\n    /**\n     * If `initial={false}` we only want to pass this to components in the first render.\n     */\n    const isInitialRender = useRef(true);\n    /**\n     * A ref containing the currently present children. When all exit animations\n     * are complete, we use this to re-render the component with the latest children\n     * *committed* rather than the latest children *rendered*.\n     */\n    const pendingPresentChildren = useRef(presentChildren);\n    /**\n     * Track which exiting children have finished animating out.\n     */\n    const exitComplete = useConstant(() => new Map());\n    /**\n     * Save children to render as React state. To ensure this component is concurrent-safe,\n     * we check for exiting children via an effect.\n     */\n    const [diffedChildren, setDiffedChildren] = useState(presentChildren);\n    const [renderedChildren, setRenderedChildren] = useState(presentChildren);\n    useIsomorphicLayoutEffect(() => {\n        isInitialRender.current = false;\n        pendingPresentChildren.current = presentChildren;\n        /**\n         * Update complete status of exiting children.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const key = getChildKey(renderedChildren[i]);\n            if (!presentKeys.includes(key)) {\n                if (exitComplete.get(key) !== true) {\n                    exitComplete.set(key, false);\n                }\n            }\n            else {\n                exitComplete.delete(key);\n            }\n        }\n    }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")]);\n    const exitingChildren = [];\n    if (presentChildren !== diffedChildren) {\n        let nextChildren = [...presentChildren];\n        /**\n         * Loop through all the currently rendered components and decide which\n         * are exiting.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const child = renderedChildren[i];\n            const key = getChildKey(child);\n            if (!presentKeys.includes(key)) {\n                nextChildren.splice(i, 0, child);\n                exitingChildren.push(child);\n            }\n        }\n        /**\n         * If we're in \"wait\" mode, and we have exiting children, we want to\n         * only render these until they've all exited.\n         */\n        if (mode === \"wait\" && exitingChildren.length) {\n            nextChildren = exitingChildren;\n        }\n        setRenderedChildren(onlyElements(nextChildren));\n        setDiffedChildren(presentChildren);\n        /**\n         * Early return to ensure once we've set state with the latest diffed\n         * children, we can immediately re-render.\n         */\n        return null;\n    }\n    if (process.env.NODE_ENV !== \"production\" &&\n        mode === \"wait\" &&\n        renderedChildren.length > 1) {\n        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n    }\n    /**\n     * If we've been provided a forceRender function by the LayoutGroupContext,\n     * we can use it to force a re-render amongst all surrounding components once\n     * all components have finished animating out.\n     */\n    const { forceRender } = useContext(LayoutGroupContext);\n    return (jsx(Fragment, { children: renderedChildren.map((child) => {\n            const key = getChildKey(child);\n            const isPresent = propagate && !isParentPresent\n                ? false\n                : presentChildren === renderedChildren ||\n                    presentKeys.includes(key);\n            const onExit = () => {\n                if (exitComplete.has(key)) {\n                    exitComplete.set(key, true);\n                }\n                else {\n                    return;\n                }\n                let isEveryExitComplete = true;\n                exitComplete.forEach((isExitComplete) => {\n                    if (!isExitComplete)\n                        isEveryExitComplete = false;\n                });\n                if (isEveryExitComplete) {\n                    forceRender?.();\n                    setRenderedChildren(pendingPresentChildren.current);\n                    propagate && safeToRemove?.();\n                    onExitComplete && onExitComplete();\n                }\n            };\n            return (jsx(PresenceChild, { isPresent: isPresent, initial: !isInitialRender.current || initial\n                    ? undefined\n                    : false, custom: custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, root: root, onExitComplete: isPresent ? undefined : onExit, anchorX: anchorX, children: child }, key));\n        }) }));\n};\n\nexport { AnimatePresence };\n","import React, { useState, useRef, useEffect, useCallback } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\n\nconst MessageInput = ({ onSend, onSocketAction }) => {\n    const [text, setText] = useState('');\n    const [isRecording, setIsRecording] = useState(false);\n    const [recordingType, setRecordingType] = useState(null); // 'audio' | 'video'\n    const [recordingTime, setRecordingTime] = useState(0);\n    const [isUploading, setIsUploading] = useState(false);\n    const [facingMode, setFacingMode] = useState('user');\n\n    const textareaRef = useRef(null);\n    const mediaRecorderRef = useRef(null);\n    const chunksRef = useRef([]);\n    const timerRef = useRef(null);\n    const fileInputRef = useRef(null);\n\n    // Video Refs\n    const videoSourceRef = useRef(null); // Hidden video element for raw stream\n    const canvasRef = useRef(null);      // Canvas for processing/displaying\n    const streamRef = useRef(null);      // Current active stream (audio+video or audio)\n    const animationFrameRef = useRef(null);\n\n    // Auto-resize textarea\n    useEffect(() => {\n        if (textareaRef.current) {\n            textareaRef.current.style.height = 'auto';\n            textareaRef.current.style.height = textareaRef.current.scrollHeight + 'px';\n        }\n    }, [text]);\n\n    const websocketRef = useRef(null);\n\n    // Cleanup on unmount\n    useEffect(() => {\n        return () => {\n            cleanupMedia();\n        };\n    }, []);\n\n    const cleanupMedia = useCallback(() => {\n        // 1. Stop all tracks in the active stream\n        if (streamRef.current) {\n            streamRef.current.getTracks().forEach(track => track.stop());\n            streamRef.current = null;\n        }\n\n        // 2. Stop the video source element to release hardware\n        if (videoSourceRef.current) {\n            videoSourceRef.current.pause();\n            videoSourceRef.current.srcObject = null;\n        }\n\n        // 3. Stop animation frame\n        if (animationFrameRef.current) {\n            cancelAnimationFrame(animationFrameRef.current);\n            animationFrameRef.current = null;\n        }\n\n        // 4. Close WebSocket if open\n        if (websocketRef.current) {\n            websocketRef.current.close();\n            websocketRef.current = null;\n        }\n    }, []);\n\n    const handleKeyDown = (e) => {\n        if (e.key === 'Enter' && !e.shiftKey) {\n            e.preventDefault();\n            handleSend();\n        }\n    };\n\n    const handleSend = () => {\n        if (text.trim()) {\n            onSend(text);\n            setText('');\n            if (textareaRef.current) {\n                textareaRef.current.style.height = 'auto';\n                textareaRef.current.focus();\n            }\n        }\n    };\n\n    const drawCanvas = () => {\n        if (videoSourceRef.current && canvasRef.current && !videoSourceRef.current.paused && !videoSourceRef.current.ended) {\n            const ctx = canvasRef.current.getContext('2d');\n            // Draw video to canvas\n            ctx.drawImage(videoSourceRef.current, 0, 0, canvasRef.current.width, canvasRef.current.height);\n            animationFrameRef.current = requestAnimationFrame(drawCanvas);\n        }\n    };\n\n    const getSupportedMimeType = () => {\n        const types = ['video/mp4', 'video/webm;codecs=h264', 'video/webm'];\n        for (const type of types) {\n            if (MediaRecorder.isTypeSupported(type)) {\n                return type;\n            }\n        }\n        return 'video/webm';\n    };\n\n    const startRecording = async (type) => {\n        try {\n            cleanupMedia(); // Ensure clean slate\n\n            let recorderStream;\n            let mimeType = 'audio/webm'; // Default\n\n            // Setup Stream\n            if (type === 'video') {\n                const constraints = {\n                    video: { facingMode: facingMode },\n                    audio: true\n                };\n\n                const rawStream = await navigator.mediaDevices.getUserMedia(constraints);\n                streamRef.current = rawStream;\n\n                // Setup Canvas for Preview\n                if (canvasRef.current && videoSourceRef.current) {\n                    videoSourceRef.current.srcObject = rawStream;\n                    await videoSourceRef.current.play();\n\n                    // Set canvas size to match video\n                    canvasRef.current.width = videoSourceRef.current.videoWidth;\n                    canvasRef.current.height = videoSourceRef.current.videoHeight;\n\n                    // Start Drawing Loop\n                    drawCanvas();\n\n                    // Use the RAW stream for recording to avoid mirror affects?\n                    // actually, the user wants \"Smart Mirroring (No Reversing)\".\n                    // \"Capture the raw, un-mirrored stream in MediaRecorder.\"\n                    // So we use 'rawStream' directly if possible?\n                    // But we used canvas before. Let's stick to canvas captureStream for consistency if we were drawing effects,\n                    // BUT, if we draw raw video to canvas, canvas is raw.\n                    // We only flip the canvas VIEW with CSS.\n                    // So 'canvasStream' IS raw/unmirrored. Correct.\n\n                    const canvasStream = canvasRef.current.captureStream(30);\n\n                    // Add audio track from raw stream\n                    const audioTrack = rawStream.getAudioTracks()[0];\n                    if (audioTrack) {\n                        canvasStream.addTrack(audioTrack);\n                    }\n\n                    recorderStream = canvasStream;\n                    mimeType = getSupportedMimeType();\n                }\n            } else {\n                // Audio Only\n                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n                streamRef.current = stream;\n                recorderStream = stream;\n                mimeType = 'audio/webm';\n            }\n\n            // Setup MediaRecorder\n            const mediaRecorder = new MediaRecorder(recorderStream, { mimeType });\n            mediaRecorderRef.current = mediaRecorder;\n\n            // Setup WebSocket for Streaming\n            if (type === 'video') {\n                // Detect protocol\n                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n                const host = window.location.host; // includes port\n                const wsUrl = `${protocol}//${host}/ws/chat/stream`;\n\n                const ws = new WebSocket(wsUrl);\n                websocketRef.current = ws;\n\n                ws.onopen = () => {\n                    console.log('Video Stream Connected');\n                    mediaRecorder.start(100); // 100ms chunks\n                };\n\n                ws.onerror = (e) => {\n                    console.error('WebSocket Error', e);\n                    // Fallback or alert?\n                };\n\n                mediaRecorder.ondataavailable = (e) => {\n                    if (e.data.size > 0 && ws.readyState === WebSocket.OPEN) {\n                        ws.send(e.data);\n                    }\n                };\n\n                mediaRecorder.onstop = () => {\n                    // Close WS\n                    if (ws.readyState === WebSocket.OPEN) {\n                        ws.close();\n                    }\n                    cleanupMedia();\n                };\n\n            } else {\n                // Audio legacy upload flow\n                chunksRef.current = [];\n                mediaRecorder.ondataavailable = (e) => {\n                    if (e.data.size > 0) chunksRef.current.push(e.data);\n                };\n                mediaRecorder.onstop = () => {\n                    const blob = new Blob(chunksRef.current, { type: mimeType });\n                    uploadFile(blob, type, 'webm');\n                    cleanupMedia();\n                };\n                mediaRecorder.start();\n            }\n\n            setIsRecording(true);\n            setRecordingType(type);\n            setRecordingTime(0);\n\n            timerRef.current = setInterval(() => {\n                setRecordingTime(prev => prev + 1);\n            }, 1000);\n\n        } catch (err) {\n            console.error(\"Error accessing media devices:\", err);\n            alert(\"Could not access camera/microphone. Please check permissions.\");\n        }\n    };\n\n    const switchCamera = async () => {\n        if (recordingType === 'video' && streamRef.current) {\n            const newMode = facingMode === 'user' ? 'environment' : 'user';\n            setFacingMode(newMode);\n\n            try {\n                // 1. Get new video stream\n                const newStream = await navigator.mediaDevices.getUserMedia({\n                    video: { facingMode: newMode }\n                });\n\n                // 2. Update Video Element (source for canvas)\n                const oldVideoTrack = streamRef.current.getVideoTracks()[0];\n                if (oldVideoTrack) oldVideoTrack.stop(); // Stop old camera\n\n                videoSourceRef.current.srcObject = newStream;\n                await videoSourceRef.current.play();\n\n                // Add new track to tracking ref so it gets cleaned up\n                // Note: The 'recorderStream' from canvas keeps working because it grabs the canvas pixels\n                const newVideoTrack = newStream.getVideoTracks()[0];\n                streamRef.current.addTrack(newVideoTrack);\n                streamRef.current.removeTrack(oldVideoTrack);\n\n            } catch (err) {\n                console.error(\"Error switching camera:\", err);\n            }\n        }\n    };\n\n\n    const stopRecording = () => {\n        if (mediaRecorderRef.current && isRecording) {\n            mediaRecorderRef.current.stop();\n            setIsRecording(false);\n            setRecordingType(null);\n            clearInterval(timerRef.current);\n        }\n    };\n\n    const cancelRecording = () => {\n        if (mediaRecorderRef.current && isRecording) {\n            mediaRecorderRef.current.onstop = null; // Prevent upload\n            mediaRecorderRef.current.stop();\n            cleanupMedia();\n            setIsRecording(false);\n            setRecordingType(null);\n            clearInterval(timerRef.current);\n        }\n    };\n\n    const handleFileChange = (e) => {\n        const file = e.target.files[0];\n        if (file) {\n            let type = 'file';\n            let ext = file.name.split('.').pop(); // Simple extension extraction\n            if (file.type.startsWith('image/')) type = 'image';\n            else if (file.type.startsWith('video/')) type = 'video';\n            else if (file.type.startsWith('audio/')) type = 'audio';\n\n            uploadFile(file, type, ext);\n        }\n    };\n\n    const uploadFile = async (fileBlob, type, ext = 'webm') => {\n        setIsUploading(true);\n        const formData = new FormData();\n        const filename = type === 'image' ? (fileBlob.name || 'image.png') : `recording.${ext}`;\n        // If fileBlob has a name (from input), use it if type isn't generic\n        const finalName = fileBlob.name || filename;\n\n        formData.append('file', fileBlob, finalName);\n\n        // This is where we could assume the backend detects type. \n        // For video messages, we send it as a file upload.\n        // App.js / ChatWindow needs to know if it's \"video\" or \"file\".\n        // The backend `upload_file` returns a URL.\n        // We then emit a message with type.\n\n        try {\n            const res = await fetch('/api/upload', {\n                method: 'POST',\n                body: formData\n            });\n            const data = await res.json();\n            if (data.url) {\n                // Send as message\n                onSend({ msg: data.url, type: type });\n            }\n        } catch (err) {\n            console.error(\"Upload failed\", err);\n            alert(\"Upload failed.\");\n        } finally {\n            setIsUploading(false);\n            if (fileInputRef.current) fileInputRef.current.value = '';\n        }\n    };\n\n    const formatTime = (seconds) => {\n        const m = Math.floor(seconds / 60);\n        const s = seconds % 60;\n        return `${m}:${s < 10 ? '0' : ''}${s}`;\n    };\n\n    // Emoji Helper\n    const addEmoji = (emoji) => {\n        setText(prev => prev + emoji);\n    };\n\n    // --- Gesture Engine State ---\n    const [mediaMode, setMediaMode] = useState('audio'); // 'audio' | 'video'\n    const gestureStartTime = useRef(0);\n    const longPressTimer = useRef(null);\n    const isLocked = useRef(false);\n    const startY = useRef(0);\n    const startX = useRef(0);\n\n    // Dynamic Morphing Variants\n    const iconVariants = {\n        initial: { scale: 0.8, rotate: -90, opacity: 0 },\n        animate: { scale: 1, rotate: 0, opacity: 1 },\n        exit: { scale: 0.8, rotate: 90, opacity: 0 },\n        tap: { scale: 0.9 }\n    };\n\n    // --- Gesture Handlers ---\n    const handlePointerDown = (e) => {\n        gestureStartTime.current = Date.now();\n        isLocked.current = false;\n        startY.current = e.clientY;\n        startX.current = e.clientX;\n\n        // Start Long Press Timer\n        longPressTimer.current = setTimeout(() => {\n            // Trigger Recording\n            startRecording(mediaMode);\n        }, 200); // 200ms threshold\n    };\n\n    const handlePointerUp = (e) => {\n        clearTimeout(longPressTimer.current);\n        const duration = Date.now() - gestureStartTime.current;\n\n        if (isRecording) {\n            if (!isLocked.current) {\n                stopRecording(); // Send\n            }\n        } else {\n            if (duration < 200) {\n                // Tap: Toggle Mode\n                setMediaMode(prev => prev === 'audio' ? 'video' : 'audio');\n            }\n        }\n    };\n\n    const handlePointerMove = (e) => {\n        if (!isRecording || isLocked.current) return;\n\n        const deltaY = startY.current - e.clientY; // Up is positive\n        const deltaX = startX.current - e.clientX; // Left is positive\n\n        // Lock Logic (Swipe Up)\n        if (deltaY > 60) {\n            isLocked.current = true;\n            // Visual Feedback for Lock?\n        }\n\n        // Cancel Logic (Swipe Left)\n        if (deltaX > 60) {\n            cancelRecording();\n        }\n    };\n\n    // --- RENDER ---\n\n    return (\n        <div className=\"message-input-stack\">\n            {/* Recording Overlay */}\n            <AnimatePresence>\n                {isRecording && (\n                    <motion.div\n                        className=\"input-container recording-mode\"\n                        initial={{ opacity: 0, y: 50 }}\n                        animate={{ opacity: 1, y: 0 }}\n                        exit={{ opacity: 0, y: 50 }}\n                    >\n                        {/* Hidden Video Source for Canvas */}\n                        <video\n                            ref={videoSourceRef}\n                            style={{ display: 'none' }}\n                            playsInline\n                            muted\n                            autoPlay\n                        />\n\n                        {/* Video Preview - Circular Pulse */}\n                        {recordingType === 'video' && (\n                            <div className=\"video-preview-circle-container\">\n                                <canvas\n                                    ref={canvasRef}\n                                    className=\"video-preview-feed-circle\"\n                                    style={{\n                                        transform: facingMode === 'user' ? 'scaleX(-1)' : 'none',\n                                    }}\n                                />\n                                <div className=\"recording-pulse-border\"></div>\n                            </div>\n                        )}\n\n                        <div className=\"recording-status\">\n                            <span className=\"rec-dot\"></span>\n                            <span className=\"rec-time\">{formatTime(recordingTime)}</span>\n                            {isLocked.current && <span className=\"rec-locked\">ðŸ”’ Locked</span>}\n                        </div>\n\n                        <div className=\"recording-controls\">\n                            <button className=\"btn-cancel-rec\" onClick={cancelRecording}>Cancel</button>\n                            <button className=\"btn-send-rec\" onClick={stopRecording}>Stop & Send</button>\n                        </div>\n                    </motion.div>\n                )}\n            </AnimatePresence>\n\n            {!isRecording && (\n                <div className=\"input-pill-container\">\n                    {/* Attachment / Bot Menu */}\n                    <AnimatePresence mode=\"wait\">\n                        {text.startsWith('/') ? (\n                            <motion.button\n                                key=\"bot-cmd\"\n                                className=\"pin-btn bot-cmd-btn\"\n                                onClick={() => {/* Open Bot Menu */ }}\n                                initial={{ scale: 0, rotate: -180 }}\n                                animate={{ scale: 1, rotate: 0 }}\n                                exit={{ scale: 0, rotate: 180 }}\n                                transition={{ type: 'spring', stiffness: 300, damping: 20 }}\n                                style={{ color: '#3390ec' }} // Telegram Blue\n                            >\n                                ðŸ¤–\n                            </motion.button>\n                        ) : (\n                            <motion.button\n                                key=\"attach\"\n                                className=\"pin-btn\"\n                                onClick={() => fileInputRef.current.click()}\n                                whileTap={{ scale: 0.9 }}\n                                initial={{ scale: 0, rotate: 180 }}\n                                animate={{ scale: 1, rotate: 0 }}\n                                exit={{ scale: 0, rotate: -180 }}\n                                transition={{ type: 'spring', stiffness: 300, damping: 20 }}\n                            >\n                                ðŸ“Ž\n                            </motion.button>\n                        )}\n                    </AnimatePresence>\n\n                    <div className=\"input-pill-box\">\n                        <textarea\n                            ref={textareaRef}\n                            className=\"input-field-pill\"\n                            placeholder=\"Message...\"\n                            value={text}\n                            onChange={(e) => setText(e.target.value)}\n                            onKeyDown={handleKeyDown}\n                            rows={1}\n                            disabled={isUploading}\n                        />\n\n                        {/* Morphing Send/Mic Button */}\n                        <AnimatePresence mode=\"popLayout\">\n                            {text.trim() ? (\n                                <motion.button\n                                    key=\"send\"\n                                    className=\"send-btn-pill\"\n                                    onClick={handleSend}\n                                    variants={iconVariants}\n                                    initial=\"initial\"\n                                    animate=\"animate\"\n                                    exit=\"exit\"\n                                    whileTap=\"tap\"\n                                    transition={{ type: 'spring', stiffness: 300, damping: 20 }}\n                                >\n                                    âž¤\n                                </motion.button>\n                            ) : (\n                                <motion.div\n                                    key=\"media\"\n                                    className=\"media-gesture-btn\"\n                                    onPointerDown={handlePointerDown}\n                                    onPointerUp={handlePointerUp}\n                                    onPointerMove={handlePointerMove}\n                                    onPointerLeave={cancelRecording} // Safety\n                                    variants={iconVariants}\n                                    initial=\"initial\"\n                                    animate=\"animate\"\n                                    exit=\"exit\"\n                                    whileTap=\"tap\"\n                                    transition={{ type: 'spring', stiffness: 300, damping: 20 }}\n                                    style={{\n                                        cursor: 'pointer',\n                                        width: '40px',\n                                        height: '40px',\n                                        display: 'flex',\n                                        alignItems: 'center',\n                                        justifyContent: 'center',\n                                        background: 'transparent'\n                                    }}\n                                >\n                                    {mediaMode === 'audio' ? 'ðŸŽ¤' : 'ðŸ“¹'}\n                                </motion.div>\n                            )}\n                        </AnimatePresence>\n                    </div>\n                </div>\n            )}\n\n            {/* Hidden File Input */}\n            <input\n                type=\"file\"\n                ref={fileInputRef}\n                style={{ display: 'none' }}\n                onChange={handleFileChange}\n                accept=\"image/*,video/*,audio/*\"\n            />\n        </div>\n    );\n};\n\nexport default MessageInput;\n"],"names":["setRef","ref","value","undefined","current","useComposedRefs","_len2","arguments","length","refs","Array","_key2","React","_len","_key","node","hasCleanup","cleanups","map","cleanup","i","composeRefs","PopChildMeasure","getSnapshotBeforeUpdate","prevProps","element","this","props","childRef","isPresent","parent","offsetParent","parentWidth","isHTMLElement","offsetWidth","size","sizeRef","height","offsetHeight","width","top","offsetTop","left","offsetLeft","right","componentDidUpdate","render","children","PopChild","_ref","anchorX","root","id","useId","useRef","nonce","useContext","MotionConfigContext","composedRef","useInsertionEffect","x","concat","dataset","motionPopId","style","document","createElement","head","appendChild","sheet","insertRule","contains","removeChild","jsx","PresenceChild","initial","onExitComplete","custom","presenceAffectsLayout","mode","presenceChildren","useConstant","newChildrenMap","isReusedContext","context","useMemo","childId","set","isComplete","values","register","delete","_objectSpread","forEach","_","key","PresenceContext","Provider","Map","getChildKey","child","onlyElements","filtered","Children","isValidElement","push","AnimatePresence","propagate","isParentPresent","safeToRemove","usePresence","presentChildren","presentKeys","isInitialRender","pendingPresentChildren","exitComplete","diffedChildren","setDiffedChildren","useState","renderedChildren","setRenderedChildren","useIsomorphicLayoutEffect","includes","get","join","exitingChildren","nextChildren","splice","forceRender","LayoutGroupContext","Fragment","onExit","has","isEveryExitComplete","isExitComplete","onSend","onSocketAction","text","setText","isRecording","setIsRecording","recordingType","setRecordingType","recordingTime","setRecordingTime","isUploading","setIsUploading","facingMode","setFacingMode","textareaRef","mediaRecorderRef","chunksRef","timerRef","fileInputRef","videoSourceRef","canvasRef","streamRef","animationFrameRef","useEffect","scrollHeight","websocketRef","cleanupMedia","useCallback","getTracks","track","stop","pause","srcObject","cancelAnimationFrame","close","handleSend","trim","focus","drawCanvas","paused","ended","getContext","drawImage","requestAnimationFrame","startRecording","async","recorderStream","mimeType","type","constraints","video","audio","rawStream","navigator","mediaDevices","getUserMedia","play","videoWidth","videoHeight","canvasStream","captureStream","audioTrack","getAudioTracks","addTrack","getSupportedMimeType","types","MediaRecorder","isTypeSupported","stream","mediaRecorder","protocol","window","location","host","wsUrl","ws","WebSocket","onopen","console","log","start","onerror","e","error","ondataavailable","data","readyState","OPEN","send","onstop","blob","Blob","uploadFile","setInterval","prev","err","alert","stopRecording","clearInterval","cancelRecording","fileBlob","ext","formData","FormData","filename","name","finalName","append","res","fetch","method","body","json","url","msg","mediaMode","setMediaMode","gestureStartTime","longPressTimer","isLocked","startY","startX","iconVariants","scale","rotate","opacity","animate","exit","tap","_jsxs","className","_jsx","motion","div","y","display","playsInline","muted","autoPlay","transform","seconds","m","Math","floor","s","formatTime","onClick","startsWith","button","transition","stiffness","damping","color","click","whileTap","placeholder","onChange","target","onKeyDown","shiftKey","preventDefault","rows","disabled","variants","onPointerDown","Date","now","clientY","clientX","setTimeout","onPointerUp","clearTimeout","duration","onPointerMove","deltaY","deltaX","onPointerLeave","cursor","alignItems","justifyContent","background","file","files","split","pop","accept"],"ignoreList":[],"sourceRoot":""}