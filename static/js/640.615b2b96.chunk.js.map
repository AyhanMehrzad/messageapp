{"version":3,"file":"static/js/640.615b2b96.chunk.js","mappings":"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","sources":["components/MessageInput.js"],"sourcesContent":["import React, { useState, useRef, useEffect, useCallback } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\n\nconst MessageInput = ({ onSend, onSocketAction }) => {\n    const [text, setText] = useState('');\n    const [isRecording, setIsRecording] = useState(false);\n    const [recordingType, setRecordingType] = useState(null); // 'audio' | 'video'\n    const [recordingTime, setRecordingTime] = useState(0);\n    const [isUploading, setIsUploading] = useState(false);\n    const [facingMode, setFacingMode] = useState('user');\n\n    const textareaRef = useRef(null);\n    const mediaRecorderRef = useRef(null);\n    const chunksRef = useRef([]);\n    const timerRef = useRef(null);\n    const fileInputRef = useRef(null);\n\n    // Video Refs\n    const videoSourceRef = useRef(null); // Hidden video element for raw stream\n    const canvasRef = useRef(null);      // Canvas for processing/displaying\n    const streamRef = useRef(null);      // Current active stream (audio+video or audio)\n    const animationFrameRef = useRef(null);\n\n    // Auto-resize textarea\n    useEffect(() => {\n        if (textareaRef.current) {\n            textareaRef.current.style.height = 'auto';\n            textareaRef.current.style.height = textareaRef.current.scrollHeight + 'px';\n        }\n    }, [text]);\n\n    // Cleanup on unmount\n    useEffect(() => {\n        return () => {\n            cleanupMedia();\n        };\n    }, []);\n\n    const cleanupMedia = useCallback(() => {\n        if (streamRef.current) {\n            streamRef.current.getTracks().forEach(track => track.stop());\n            streamRef.current = null;\n        }\n        if (animationFrameRef.current) {\n            cancelAnimationFrame(animationFrameRef.current);\n            animationFrameRef.current = null;\n        }\n    }, []);\n\n    const handleKeyDown = (e) => {\n        if (e.key === 'Enter' && !e.shiftKey) {\n            e.preventDefault();\n            handleSend();\n        }\n    };\n\n    const handleSend = () => {\n        if (text.trim()) {\n            onSend(text);\n            setText('');\n            if (textareaRef.current) {\n                textareaRef.current.style.height = 'auto';\n                textareaRef.current.focus();\n            }\n        }\n    };\n\n    const drawCanvas = () => {\n        if (videoSourceRef.current && canvasRef.current && !videoSourceRef.current.paused && !videoSourceRef.current.ended) {\n            const ctx = canvasRef.current.getContext('2d');\n            // Draw video to canvas\n            ctx.drawImage(videoSourceRef.current, 0, 0, canvasRef.current.width, canvasRef.current.height);\n            animationFrameRef.current = requestAnimationFrame(drawCanvas);\n        }\n    };\n\n    const getSupportedMimeType = () => {\n        const types = ['video/mp4', 'video/webm;codecs=h264', 'video/webm'];\n        for (const type of types) {\n            if (MediaRecorder.isTypeSupported(type)) {\n                return type;\n            }\n        }\n        return 'video/webm';\n    };\n\n    const startRecording = async (type) => {\n        try {\n            cleanupMedia(); // Ensure clean slate\n\n            let recorderStream;\n            let mimeType = 'audio/webm';\n            let ext = 'webm';\n\n            if (type === 'video') {\n                const constraints = {\n                    video: { facingMode: facingMode },\n                    audio: true\n                };\n\n                const rawStream = await navigator.mediaDevices.getUserMedia(constraints);\n                streamRef.current = rawStream;\n\n                // Setup Canvas\n                if (canvasRef.current && videoSourceRef.current) {\n                    videoSourceRef.current.srcObject = rawStream;\n                    await videoSourceRef.current.play();\n\n                    // Set canvas size to match video\n                    canvasRef.current.width = videoSourceRef.current.videoWidth;\n                    canvasRef.current.height = videoSourceRef.current.videoHeight;\n\n                    // Start Drawing Loop\n                    drawCanvas();\n\n                    // Create Stream from Canvas\n                    const canvasStream = canvasRef.current.captureStream(30);\n\n                    // Add audio track from raw stream\n                    const audioTrack = rawStream.getAudioTracks()[0];\n                    if (audioTrack) {\n                        canvasStream.addTrack(audioTrack);\n                    }\n\n                    recorderStream = canvasStream;\n                    mimeType = getSupportedMimeType();\n                    ext = mimeType.includes('mp4') ? 'mp4' : 'webm';\n                }\n            } else {\n                // Audio Only\n                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n                streamRef.current = stream;\n                recorderStream = stream;\n                mimeType = 'audio/webm';\n            }\n\n            const mediaRecorder = new MediaRecorder(recorderStream, { mimeType });\n            mediaRecorderRef.current = mediaRecorder;\n            chunksRef.current = [];\n\n            mediaRecorder.ondataavailable = (e) => {\n                if (e.data.size > 0) {\n                    chunksRef.current.push(e.data);\n                }\n            };\n\n            mediaRecorder.onstop = () => {\n                const blob = new Blob(chunksRef.current, { type: mimeType });\n                uploadFile(blob, type, ext);\n                cleanupMedia();\n            };\n\n            mediaRecorder.start();\n            setIsRecording(true);\n            setRecordingType(type);\n            setRecordingTime(0);\n\n            timerRef.current = setInterval(() => {\n                setRecordingTime(prev => prev + 1);\n            }, 1000);\n\n        } catch (err) {\n            console.error(\"Error accessing media devices:\", err);\n            alert(\"Could not access camera/microphone. Please check permissions.\");\n        }\n    };\n\n    const switchCamera = async () => {\n        if (recordingType === 'video' && streamRef.current) {\n            const newMode = facingMode === 'user' ? 'environment' : 'user';\n            setFacingMode(newMode);\n\n            try {\n                // 1. Get new video stream\n                const newStream = await navigator.mediaDevices.getUserMedia({\n                    video: { facingMode: newMode }\n                });\n\n                // 2. Update Video Element (source for canvas)\n                const oldVideoTrack = streamRef.current.getVideoTracks()[0];\n                if (oldVideoTrack) oldVideoTrack.stop(); // Stop old camera\n\n                videoSourceRef.current.srcObject = newStream;\n                await videoSourceRef.current.play();\n\n                // Add new track to tracking ref so it gets cleaned up\n                // Note: The 'recorderStream' from canvas keeps working because it grabs the canvas pixels\n                const newVideoTrack = newStream.getVideoTracks()[0];\n                streamRef.current.addTrack(newVideoTrack);\n                streamRef.current.removeTrack(oldVideoTrack);\n\n            } catch (err) {\n                console.error(\"Error switching camera:\", err);\n            }\n        }\n    };\n\n\n    const stopRecording = () => {\n        if (mediaRecorderRef.current && isRecording) {\n            mediaRecorderRef.current.stop();\n            setIsRecording(false);\n            setRecordingType(null);\n            clearInterval(timerRef.current);\n        }\n    };\n\n    const cancelRecording = () => {\n        if (mediaRecorderRef.current && isRecording) {\n            mediaRecorderRef.current.onstop = null; // Prevent upload\n            mediaRecorderRef.current.stop();\n            cleanupMedia();\n            setIsRecording(false);\n            setRecordingType(null);\n            clearInterval(timerRef.current);\n        }\n    };\n\n    const handleFileChange = (e) => {\n        const file = e.target.files[0];\n        if (file) {\n            let type = 'file';\n            let ext = file.name.split('.').pop(); // Simple extension extraction\n            if (file.type.startsWith('image/')) type = 'image';\n            else if (file.type.startsWith('video/')) type = 'video';\n            else if (file.type.startsWith('audio/')) type = 'audio';\n\n            uploadFile(file, type, ext);\n        }\n    };\n\n    const uploadFile = async (fileBlob, type, ext = 'webm') => {\n        setIsUploading(true);\n        const formData = new FormData();\n        const filename = type === 'image' ? (fileBlob.name || 'image.png') : `recording.${ext}`;\n        // If fileBlob has a name (from input), use it if type isn't generic\n        const finalName = fileBlob.name || filename;\n\n        formData.append('file', fileBlob, finalName);\n\n        // This is where we could assume the backend detects type. \n        // For video messages, we send it as a file upload.\n        // App.js / ChatWindow needs to know if it's \"video\" or \"file\".\n        // The backend `upload_file` returns a URL.\n        // We then emit a message with type.\n\n        try {\n            const res = await fetch('/api/upload', {\n                method: 'POST',\n                body: formData\n            });\n            const data = await res.json();\n            if (data.url) {\n                // Send as message\n                onSend({ msg: data.url, type: type });\n            }\n        } catch (err) {\n            console.error(\"Upload failed\", err);\n            alert(\"Upload failed.\");\n        } finally {\n            setIsUploading(false);\n            if (fileInputRef.current) fileInputRef.current.value = '';\n        }\n    };\n\n    const formatTime = (seconds) => {\n        const m = Math.floor(seconds / 60);\n        const s = seconds % 60;\n        return `${m}:${s < 10 ? '0' : ''}${s}`;\n    };\n\n    // Emoji Helper\n    const addEmoji = (emoji) => {\n        setText(prev => prev + emoji);\n    };\n\n    // --- RENDER ---\n\n    // Action Bar Handlers\n    const handleAction = (action) => {\n        if (onSocketAction) {\n            onSocketAction(action);\n        }\n    };\n\n    if (isRecording) {\n        return (\n            <div className=\"input-container recording-mode\">\n                {/* Hidden Video Source for Canvas */}\n                <video\n                    ref={videoSourceRef}\n                    style={{ display: 'none' }}\n                    playsInline\n                    muted\n                    autoPlay\n                />\n\n                {/* Canvas Preview - Circular & Centered */}\n                {recordingType === 'video' && (\n                    <div className=\"video-preview-circle-container\">\n                        <canvas\n                            ref={canvasRef}\n                            className=\"video-preview-feed-circle\"\n                        />\n                        {/* Switch Camera Button Overlay */}\n                        <button\n                            className=\"btn-switch-camera\"\n                            onClick={switchCamera}\n                            style={{\n                                position: 'absolute',\n                                bottom: '20px',\n                                right: '50%',\n                                transform: 'translateX(50%)',\n                                zIndex: 3000,\n                                background: 'rgba(0,0,0,0.5)',\n                                color: 'white',\n                                border: '1px solid white',\n                                borderRadius: '20px',\n                                padding: '5px 15px',\n                                cursor: 'pointer'\n                            }}\n                        >\n                            üîÑ Flip\n                        </button>\n                    </div>\n                )}\n\n                {/* Recording Status & Timer */}\n                <div className=\"recording-status\">\n                    <span className=\"rec-dot\"></span>\n                    <span className=\"rec-time\">{formatTime(recordingTime)}</span>\n                </div>\n\n                {/* Cancel / Send Controls */}\n                <div className=\"recording-controls\">\n                    <button className=\"btn-cancel-rec\" onClick={cancelRecording}>Cancel</button>\n                    <button className=\"btn-send-rec\" onClick={stopRecording}>Stop & Send</button>\n                </div>\n            </div>\n        );\n    }\n\n    return (\n        <div className=\"input-block-wrapper\">\n            {/* Action Bar (Pill) - Directly above input */}\n            <div className=\"action-bar-pill\">\n                <div className=\"action-unit\" onClick={() => handleAction('clear')}>\n                    üóëÔ∏è\n                </div>\n                <div className=\"action-unit\" onClick={() => handleAction('ping')}>\n                    üîî\n                </div>\n                <div className=\"action-unit\" onClick={() => addEmoji('üòä')}>\n                    üòä\n                </div>\n                <div className=\"action-unit\" onClick={() => handleAction('exit')}>\n                    üì∫\n                </div>\n            </div>\n\n            <div className=\"input-container\">\n                {/* File Input (Hidden) */}\n                <input\n                    type=\"file\"\n                    ref={fileInputRef}\n                    style={{ display: 'none' }}\n                    onChange={handleFileChange}\n                    accept=\"image/*,video/*,audio/*,.pdf,.doc,.docx\" // Broad acceptance\n                />\n\n                <div className=\"input-pill-box\">\n                    {/* Attachment */}\n                    <button className=\"pin-btn\" onClick={() => fileInputRef.current.click()}>\n                        üìé\n                    </button>\n\n                    <textarea\n                        ref={textareaRef}\n                        className=\"input-field-pill\"\n                        placeholder=\"Message...\"\n                        value={text}\n                        onChange={(e) => setText(e.target.value)}\n                        onKeyDown={handleKeyDown}\n                        rows={1}\n                        disabled={isUploading}\n                    />\n\n                    {/* Send or Mic/Video */}\n                    {text.trim() ? (\n                        <button className=\"send-btn-pill\" onClick={handleSend} disabled={isUploading}>\n                            {isUploading ? '...' : '‚û§'}\n                        </button>\n                    ) : (\n                        <div className=\"media-actions-pill\">\n                            <button\n                                className=\"media-btn-pill video-btn\"\n                                onClick={() => startRecording('video')}\n                                disabled={isUploading}\n                            >\n                                üìπ\n                            </button>\n                            <button\n                                className=\"media-btn-pill mic-btn\"\n                                onClick={() => startRecording('audio')}\n                                disabled={isUploading}\n                            >\n                                üé§\n                            </button>\n                        </div>\n                    )}\n                </div>\n            </div>\n        </div>\n    );\n};\n\nexport default MessageInput;\n"],"names":["_ref","onSend","onSocketAction","text","setText","useState","isRecording","setIsRecording","recordingType","setRecordingType","recordingTime","setRecordingTime","isUploading","setIsUploading","facingMode","setFacingMode","textareaRef","useRef","mediaRecorderRef","chunksRef","timerRef","fileInputRef","videoSourceRef","canvasRef","streamRef","animationFrameRef","useEffect","current","style","height","scrollHeight","cleanupMedia","useCallback","getTracks","forEach","track","stop","cancelAnimationFrame","handleSend","trim","focus","drawCanvas","paused","ended","getContext","drawImage","width","requestAnimationFrame","startRecording","async","recorderStream","mimeType","ext","type","constraints","video","audio","rawStream","navigator","mediaDevices","getUserMedia","srcObject","play","videoWidth","videoHeight","canvasStream","captureStream","audioTrack","getAudioTracks","addTrack","getSupportedMimeType","types","MediaRecorder","isTypeSupported","includes","stream","mediaRecorder","ondataavailable","e","data","size","push","onstop","blob","Blob","uploadFile","start","setInterval","prev","err","console","error","alert","switchCamera","newMode","newStream","oldVideoTrack","getVideoTracks","newVideoTrack","removeTrack","stopRecording","clearInterval","cancelRecording","fileBlob","arguments","length","undefined","formData","FormData","filename","name","concat","finalName","append","res","fetch","method","body","json","url","msg","value","formatTime","seconds","m","Math","floor","s","handleAction","action","_jsxs","className","children","_jsx","ref","display","playsInline","muted","autoPlay","onClick","position","bottom","right","transform","zIndex","background","color","border","borderRadius","padding","cursor","addEmoji","emoji","onChange","file","target","files","split","pop","startsWith","accept","click","placeholder","onKeyDown","key","shiftKey","preventDefault","rows","disabled"],"ignoreList":[],"sourceRoot":""}