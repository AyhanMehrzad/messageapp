{"version":3,"file":"static/js/640.3e5efb8a.chunk.js","mappings":"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","sources":["components/MessageInput.js"],"sourcesContent":["import React, { useState, useRef, useEffect, useCallback, forwardRef, useImperativeHandle } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\n\nconst MessageInput = forwardRef(({ onSend, onSocketAction }, ref) => {\n    const [text, setText] = useState('');\n    const [isRecording, setIsRecording] = useState(false);\n    const [recordingType, setRecordingType] = useState(null); // 'audio' | 'video'\n    const [recordingTime, setRecordingTime] = useState(0);\n    const [isUploading, setIsUploading] = useState(false);\n    const [facingMode, setFacingMode] = useState('user');\n\n    const textareaRef = useRef(null);\n    const mediaRecorderRef = useRef(null);\n    const chunksRef = useRef([]);\n    const timerRef = useRef(null);\n    const fileInputRef = useRef(null);\n\n    // Video Refs\n    const videoSourceRef = useRef(null); // Hidden video element for raw stream\n    const canvasRef = useRef(null);      // Canvas for processing/displaying\n    const streamRef = useRef(null);      // Current active stream (audio+video or audio)\n    const animationFrameRef = useRef(null);\n\n    // Auto-resize textarea\n    useEffect(() => {\n        if (textareaRef.current) {\n            textareaRef.current.style.height = 'auto';\n            textareaRef.current.style.height = textareaRef.current.scrollHeight + 'px';\n        }\n    }, [text]);\n\n    const websocketRef = useRef(null);\n\n    useImperativeHandle(ref, () => ({\n        stopHardware: () => {\n            cancelRecording();\n            cleanupMedia();\n        }\n    }));\n\n    // Cleanup on unmount\n    useEffect(() => {\n        return () => {\n            cleanupMedia();\n        };\n    }, []);\n\n    const cleanupMedia = useCallback(() => {\n        // 1. Stop all tracks in the active stream\n        if (streamRef.current) {\n            streamRef.current.getTracks().forEach(track => track.stop());\n            streamRef.current = null;\n        }\n\n        // 2. Stop the video source element to release hardware\n        if (videoSourceRef.current) {\n            videoSourceRef.current.pause();\n            videoSourceRef.current.srcObject = null;\n        }\n\n        // 3. Stop animation frame\n        if (animationFrameRef.current) {\n            cancelAnimationFrame(animationFrameRef.current);\n            animationFrameRef.current = null;\n        }\n\n        // 4. Close WebSocket if open\n        if (websocketRef.current) {\n            websocketRef.current.close();\n            websocketRef.current = null;\n        }\n    }, []);\n\n    const handleKeyDown = (e) => {\n        if (e.key === 'Enter' && !e.shiftKey) {\n            e.preventDefault();\n            handleSend();\n        }\n    };\n\n    const handleSend = () => {\n        if (text.trim()) {\n            onSend(text);\n            setText('');\n            if (textareaRef.current) {\n                textareaRef.current.style.height = 'auto';\n                textareaRef.current.focus();\n            }\n        }\n    };\n\n    const drawCanvas = () => {\n        if (videoSourceRef.current && canvasRef.current && !videoSourceRef.current.paused && !videoSourceRef.current.ended) {\n            const ctx = canvasRef.current.getContext('2d');\n            // Draw video to canvas\n            ctx.drawImage(videoSourceRef.current, 0, 0, canvasRef.current.width, canvasRef.current.height);\n            animationFrameRef.current = requestAnimationFrame(drawCanvas);\n        }\n    };\n\n    const getSupportedMimeType = () => {\n        const types = ['video/mp4', 'video/webm;codecs=h264', 'video/webm'];\n        for (const type of types) {\n            if (MediaRecorder.isTypeSupported(type)) {\n                return type;\n            }\n        }\n        return 'video/webm';\n    };\n\n    const startRecording = async (type) => {\n        try {\n            cleanupMedia(); // Ensure clean slate\n\n            let recorderStream;\n            let mimeType = 'audio/webm'; // Default\n\n            // Setup Stream\n            if (type === 'video') {\n                const constraints = {\n                    video: { facingMode: facingMode },\n                    audio: true\n                };\n\n                const rawStream = await navigator.mediaDevices.getUserMedia(constraints);\n                streamRef.current = rawStream;\n\n                // Setup Canvas for Preview\n                if (canvasRef.current && videoSourceRef.current) {\n                    videoSourceRef.current.srcObject = rawStream;\n                    await videoSourceRef.current.play();\n\n                    // Set canvas size to match video\n                    canvasRef.current.width = videoSourceRef.current.videoWidth;\n                    canvasRef.current.height = videoSourceRef.current.videoHeight;\n\n                    // Start Drawing Loop\n                    drawCanvas();\n\n                    // Use the RAW stream for recording to avoid mirror affects?\n                    // actually, the user wants \"Smart Mirroring (No Reversing)\".\n                    // \"Capture the raw, un-mirrored stream in MediaRecorder.\"\n                    // So we use 'rawStream' directly if possible?\n                    // But we used canvas before. Let's stick to canvas captureStream for consistency if we were drawing effects,\n                    // BUT, if we draw raw video to canvas, canvas is raw.\n                    // We only flip the canvas VIEW with CSS.\n                    // So 'canvasStream' IS raw/unmirrored. Correct.\n\n                    const canvasStream = canvasRef.current.captureStream(30);\n\n                    // Add audio track from raw stream\n                    const audioTrack = rawStream.getAudioTracks()[0];\n                    if (audioTrack) {\n                        canvasStream.addTrack(audioTrack);\n                    }\n\n                    recorderStream = canvasStream;\n                    mimeType = getSupportedMimeType();\n                }\n            } else {\n                // Audio Only\n                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n                streamRef.current = stream;\n                recorderStream = stream;\n                mimeType = 'audio/webm';\n            }\n\n            // Setup MediaRecorder\n            const mediaRecorder = new MediaRecorder(recorderStream, { mimeType });\n            mediaRecorderRef.current = mediaRecorder;\n\n            // Setup WebSocket for Streaming\n            if (type === 'video') {\n                // Detect protocol\n                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n                const host = window.location.host; // includes port\n                const wsUrl = `${protocol}//${host}/ws/chat/stream`;\n\n                const ws = new WebSocket(wsUrl);\n                websocketRef.current = ws;\n\n                ws.onopen = () => {\n                    console.log('Video Stream Connected');\n                    mediaRecorder.start(100); // 100ms chunks\n                };\n\n                ws.onerror = (e) => {\n                    console.error('WebSocket Error', e);\n                    // Fallback or alert?\n                };\n\n                mediaRecorder.ondataavailable = (e) => {\n                    if (e.data.size > 0 && ws.readyState === WebSocket.OPEN) {\n                        ws.send(e.data);\n                    }\n                };\n\n                mediaRecorder.onstop = () => {\n                    // Close WS\n                    if (ws.readyState === WebSocket.OPEN) {\n                        ws.close();\n                    }\n                    cleanupMedia();\n                };\n\n            } else {\n                // Audio legacy upload flow\n                chunksRef.current = [];\n                mediaRecorder.ondataavailable = (e) => {\n                    if (e.data.size > 0) chunksRef.current.push(e.data);\n                };\n                mediaRecorder.onstop = () => {\n                    const blob = new Blob(chunksRef.current, { type: mimeType });\n                    uploadFile(blob, type, 'webm');\n                    cleanupMedia();\n                };\n                mediaRecorder.start();\n            }\n\n            setIsRecording(true);\n            setRecordingType(type);\n            setRecordingTime(0);\n\n            timerRef.current = setInterval(() => {\n                setRecordingTime(prev => prev + 1);\n            }, 1000);\n\n        } catch (err) {\n            console.error(\"Error accessing media devices:\", err);\n            alert(\"Could not access camera/microphone. Please check permissions.\");\n        }\n    };\n\n    const switchCamera = async () => {\n        if (recordingType === 'video' && streamRef.current) {\n            const newMode = facingMode === 'user' ? 'environment' : 'user';\n            setFacingMode(newMode);\n\n            try {\n                // 1. Get new video stream\n                const newStream = await navigator.mediaDevices.getUserMedia({\n                    video: { facingMode: newMode }\n                });\n\n                // 2. Update Video Element (source for canvas)\n                const oldVideoTrack = streamRef.current.getVideoTracks()[0];\n                if (oldVideoTrack) oldVideoTrack.stop(); // Stop old camera\n\n                videoSourceRef.current.srcObject = newStream;\n                await videoSourceRef.current.play();\n\n                // Add new track to tracking ref so it gets cleaned up\n                // Note: The 'recorderStream' from canvas keeps working because it grabs the canvas pixels\n                const newVideoTrack = newStream.getVideoTracks()[0];\n                streamRef.current.addTrack(newVideoTrack);\n                streamRef.current.removeTrack(oldVideoTrack);\n\n            } catch (err) {\n                console.error(\"Error switching camera:\", err);\n            }\n        }\n    };\n\n\n    const stopRecording = () => {\n        if (mediaRecorderRef.current && isRecording) {\n            mediaRecorderRef.current.stop();\n            setIsRecording(false);\n            setRecordingType(null);\n            clearInterval(timerRef.current);\n        }\n    };\n\n    const cancelRecording = () => {\n        if (mediaRecorderRef.current && isRecording) {\n            mediaRecorderRef.current.onstop = null; // Prevent upload\n            mediaRecorderRef.current.stop();\n            cleanupMedia();\n            setIsRecording(false);\n            setRecordingType(null);\n            clearInterval(timerRef.current);\n        }\n    };\n\n    const handleFileChange = (e) => {\n        const file = e.target.files[0];\n        if (file) {\n            let type = 'file';\n            let ext = file.name.split('.').pop(); // Simple extension extraction\n            if (file.type.startsWith('image/')) type = 'image';\n            else if (file.type.startsWith('video/')) type = 'video';\n            else if (file.type.startsWith('audio/')) type = 'audio';\n\n            uploadFile(file, type, ext);\n        }\n    };\n\n    const uploadFile = async (fileBlob, type, ext = 'webm') => {\n        setIsUploading(true);\n        const formData = new FormData();\n        const filename = type === 'image' ? (fileBlob.name || 'image.png') : `recording.${ext}`;\n        // If fileBlob has a name (from input), use it if type isn't generic\n        const finalName = fileBlob.name || filename;\n\n        formData.append('file', fileBlob, finalName);\n\n        // This is where we could assume the backend detects type. \n        // For video messages, we send it as a file upload.\n        // App.js / ChatWindow needs to know if it's \"video\" or \"file\".\n        // The backend `upload_file` returns a URL.\n        // We then emit a message with type.\n\n        try {\n            const res = await fetch('/api/upload', {\n                method: 'POST',\n                body: formData\n            });\n            const data = await res.json();\n            if (data.url) {\n                // Send as message\n                onSend({ msg: data.url, type: type });\n            }\n        } catch (err) {\n            console.error(\"Upload failed\", err);\n            alert(\"Upload failed.\");\n        } finally {\n            setIsUploading(false);\n            if (fileInputRef.current) fileInputRef.current.value = '';\n        }\n    };\n\n    const formatTime = (seconds) => {\n        const m = Math.floor(seconds / 60);\n        const s = seconds % 60;\n        return `${m}:${s < 10 ? '0' : ''}${s}`;\n    };\n\n    // Emoji Helper\n    const addEmoji = (emoji) => {\n        setText(prev => prev + emoji);\n    };\n\n    // --- Gesture Engine State ---\n    const [mediaMode, setMediaMode] = useState('audio'); // 'audio' | 'video'\n    const gestureStartTime = useRef(0);\n    const longPressTimer = useRef(null);\n    const isLocked = useRef(false);\n    const startY = useRef(0);\n    const startX = useRef(0);\n\n    // Dynamic Morphing Variants\n    const iconVariants = {\n        initial: { scale: 0.8, rotate: -90, opacity: 0 },\n        animate: { scale: 1, rotate: 0, opacity: 1 },\n        exit: { scale: 0.8, rotate: 90, opacity: 0 },\n        tap: { scale: 0.9 }\n    };\n\n    // --- Gesture Handlers ---\n    const handlePointerDown = (e) => {\n        gestureStartTime.current = Date.now();\n        isLocked.current = false;\n        startY.current = e.clientY;\n        startX.current = e.clientX;\n\n        // Start Long Press Timer\n        longPressTimer.current = setTimeout(() => {\n            // Trigger Recording\n            startRecording(mediaMode);\n        }, 200); // 200ms threshold\n    };\n\n    const handlePointerUp = (e) => {\n        clearTimeout(longPressTimer.current);\n        const duration = Date.now() - gestureStartTime.current;\n\n        if (isRecording) {\n            if (!isLocked.current) {\n                stopRecording(); // Send\n            }\n        } else {\n            if (duration < 200) {\n                // Tap: Toggle Mode\n                setMediaMode(prev => prev === 'audio' ? 'video' : 'audio');\n            }\n        }\n    };\n\n    const handlePointerMove = (e) => {\n        if (!isRecording || isLocked.current) return;\n\n        const deltaY = startY.current - e.clientY; // Up is positive\n        const deltaX = startX.current - e.clientX; // Left is positive\n\n        // Lock Logic (Swipe Up)\n        if (deltaY > 60) {\n            isLocked.current = true;\n            // Visual Feedback for Lock?\n        }\n\n        // Cancel Logic (Swipe Left)\n        if (deltaX > 60) {\n            cancelRecording();\n        }\n    };\n\n    // --- RENDER ---\n\n    return (\n        <div className=\"message-input-stack\">\n            {/* Recording Overlay */}\n            <AnimatePresence>\n                {isRecording && (\n                    <motion.div\n                        className=\"input-container recording-mode\"\n                        initial={{ opacity: 0, y: 50 }}\n                        animate={{ opacity: 1, y: 0 }}\n                        exit={{ opacity: 0, y: 50 }}\n                    >\n                        {/* Hidden Video Source for Canvas */}\n                        <video\n                            ref={videoSourceRef}\n                            style={{ display: 'none' }}\n                            playsInline\n                            muted\n                            autoPlay\n                        />\n\n                        {/* Video Preview - Circular Pulse */}\n                        {recordingType === 'video' && (\n                            <div className=\"video-preview-circle-container\">\n                                <canvas\n                                    ref={canvasRef}\n                                    className=\"video-preview-feed-circle\"\n                                    style={{\n                                        transform: facingMode === 'user' ? 'scaleX(-1)' : 'none',\n                                    }}\n                                />\n                                <div className=\"recording-pulse-border\"></div>\n                            </div>\n                        )}\n\n                        <div className=\"recording-status\">\n                            <span className=\"rec-dot\"></span>\n                            <span className=\"rec-time\">{formatTime(recordingTime)}</span>\n                            {isLocked.current && <span className=\"rec-locked\">ðŸ”’ Locked</span>}\n                        </div>\n\n                        <div className=\"recording-controls\">\n                            <button className=\"btn-cancel-rec\" onClick={cancelRecording}>Cancel</button>\n                            <button className=\"btn-send-rec\" onClick={stopRecording}>Stop & Send</button>\n                        </div>\n                    </motion.div>\n                )}\n            </AnimatePresence>\n\n            {!isRecording && (\n                <div className=\"input-pill-container\" style={{ display: 'flex', alignItems: 'flex-end', gap: '8px', width: '100%', maxWidth: '700px', margin: '0 auto' }}>\n\n                    <div className=\"input-pill-box\" style={{\n                        flex: 1,\n                        background: '#fff',\n                        borderRadius: '24px',\n                        display: 'flex',\n                        alignItems: 'center',\n                        padding: '6px 12px',\n                        boxShadow: '0 1px 3px rgba(0,0,0,0.1)'\n                    }}>\n                        {/* Attachment / Bot Menu (MOVED INSIDE) */}\n                        <AnimatePresence mode=\"wait\">\n                            {text.startsWith('/') ? (\n                                <motion.button\n                                    key=\"bot-cmd\"\n                                    className=\"pin-btn bot-cmd-btn\"\n                                    onClick={() => {/* Open Bot Menu */ }}\n                                    initial={{ scale: 0, rotate: -180 }}\n                                    animate={{ scale: 1, rotate: 0 }}\n                                    exit={{ scale: 0, rotate: 180 }}\n                                    transition={{ type: 'spring', stiffness: 300, damping: 20 }}\n                                    style={{ color: '#3390ec', marginRight: '8px', background: 'none', border: 'none', cursor: 'pointer', fontSize: '20px' }}\n                                >\n                                    ðŸ¤–\n                                </motion.button>\n                            ) : (\n                                <motion.button\n                                    key=\"attach\"\n                                    className=\"pin-btn\"\n                                    onClick={() => fileInputRef.current.click()}\n                                    whileTap={{ scale: 0.9 }}\n                                    initial={{ scale: 0, rotate: 180 }}\n                                    animate={{ scale: 1, rotate: 0 }}\n                                    exit={{ scale: 0, rotate: -180 }}\n                                    transition={{ type: 'spring', stiffness: 300, damping: 20 }}\n                                    style={{ color: '#707579', marginRight: '8px', background: 'none', border: 'none', cursor: 'pointer', fontSize: '22px' }}\n                                >\n                                    ðŸ“Ž\n                                </motion.button>\n                            )}\n                        </AnimatePresence>\n\n                        <textarea\n                            ref={textareaRef}\n                            className=\"input-field-pill\"\n                            placeholder=\"Message\"\n                            value={text}\n                            onChange={(e) => setText(e.target.value)}\n                            onKeyDown={handleKeyDown}\n                            rows={1}\n                            disabled={isUploading}\n                            style={{ flex: 1, border: 'none', outline: 'none', resize: 'none', fontSize: '16px', maxHeight: '100px', padding: '4px 0', fontFamily: 'inherit' }}\n                        />\n\n                        {/* Emoji Icon (NEW) */}\n                        <button\n                            className=\"emoji-btn\"\n                            onClick={() => {/* Toggle Emoji Picker */ }}\n                            style={{ background: 'none', border: 'none', cursor: 'pointer', fontSize: '22px', marginLeft: '8px', color: '#707579' }}\n                        >\n                            ðŸ˜Š\n                        </button>\n                    </div>\n\n                    {/* Morphing Send/Mic Button (MOVED OUTSIDE) */}\n                    <div className=\"action-btn-circle\" style={{ width: '48px', height: '48px', flexShrink: 0 }}>\n                        <AnimatePresence mode=\"popLayout\">\n                            {text.trim() ? (\n                                <motion.button\n                                    key=\"send\"\n                                    className=\"send-btn-pill\"\n                                    onClick={handleSend}\n                                    variants={iconVariants}\n                                    initial=\"initial\"\n                                    animate=\"animate\"\n                                    exit=\"exit\"\n                                    whileTap=\"tap\"\n                                    transition={{ type: 'spring', stiffness: 300, damping: 20 }}\n                                    style={{\n                                        width: '100%', height: '100%', borderRadius: '50%',\n                                        background: '#3390ec', color: '#fff', border: 'none',\n                                        display: 'flex', alignItems: 'center', justifyContent: 'center',\n                                        cursor: 'pointer', fontSize: '20px'\n                                    }}\n                                >\n                                    âž¤\n                                </motion.button>\n                            ) : (\n                                <motion.div\n                                    key=\"media\"\n                                    className=\"media-gesture-btn\"\n                                    onPointerDown={handlePointerDown}\n                                    onPointerUp={handlePointerUp}\n                                    onPointerMove={handlePointerMove}\n                                    onPointerLeave={cancelRecording} // Safety\n                                    variants={iconVariants}\n                                    initial=\"initial\"\n                                    animate=\"animate\"\n                                    exit=\"exit\"\n                                    whileTap=\"tap\"\n                                    transition={{ type: 'spring', stiffness: 300, damping: 20 }}\n                                    style={{\n                                        width: '100%', height: '100%', borderRadius: '50%',\n                                        background: '#f5f5f5', color: '#707579', // Telegram-style grey circle? Or maybe transparent if default\n                                        display: 'flex', alignItems: 'center', justifyContent: 'center',\n                                        cursor: 'pointer', fontSize: '24px'\n                                    }}\n                                >\n                                    {mediaMode === 'audio' ? 'ðŸŽ¤' : 'ðŸ“¹'}\n                                </motion.div>\n                            )}\n                        </AnimatePresence>\n                    </div>\n                </div>\n            )}\n\n            {/* Hidden File Input */}\n            <input\n                type=\"file\"\n                ref={fileInputRef}\n                style={{ display: 'none' }}\n                onChange={handleFileChange}\n                accept=\"image/*,video/*,audio/*\"\n            />\n        </div>\n    );\n});\n\nexport default MessageInput;\n"],"names":["forwardRef","_ref","ref","onSend","onSocketAction","text","setText","useState","isRecording","setIsRecording","recordingType","setRecordingType","recordingTime","setRecordingTime","isUploading","setIsUploading","facingMode","setFacingMode","textareaRef","useRef","mediaRecorderRef","chunksRef","timerRef","fileInputRef","videoSourceRef","canvasRef","streamRef","animationFrameRef","useEffect","current","style","height","scrollHeight","websocketRef","useImperativeHandle","stopHardware","cancelRecording","cleanupMedia","useCallback","getTracks","forEach","track","stop","pause","srcObject","cancelAnimationFrame","close","handleSend","trim","focus","drawCanvas","paused","ended","getContext","drawImage","width","requestAnimationFrame","startRecording","async","recorderStream","mimeType","type","constraints","video","audio","rawStream","navigator","mediaDevices","getUserMedia","play","videoWidth","videoHeight","canvasStream","captureStream","audioTrack","getAudioTracks","addTrack","getSupportedMimeType","types","MediaRecorder","isTypeSupported","stream","mediaRecorder","protocol","window","location","host","wsUrl","concat","ws","WebSocket","onopen","console","log","start","onerror","e","error","ondataavailable","data","size","readyState","OPEN","send","onstop","push","blob","Blob","uploadFile","setInterval","prev","err","alert","stopRecording","clearInterval","fileBlob","ext","arguments","length","undefined","formData","FormData","filename","name","finalName","append","res","fetch","method","body","json","url","msg","value","mediaMode","setMediaMode","gestureStartTime","longPressTimer","isLocked","startY","startX","iconVariants","initial","scale","rotate","opacity","animate","exit","tap","_jsxs","className","children","_jsx","AnimatePresence","motion","div","y","display","playsInline","muted","autoPlay","transform","seconds","m","Math","floor","s","formatTime","onClick","alignItems","gap","maxWidth","margin","flex","background","borderRadius","padding","boxShadow","mode","startsWith","button","transition","stiffness","damping","color","marginRight","border","cursor","fontSize","click","whileTap","placeholder","onChange","target","onKeyDown","key","shiftKey","preventDefault","rows","disabled","outline","resize","maxHeight","fontFamily","marginLeft","flexShrink","variants","justifyContent","onPointerDown","Date","now","clientY","clientX","setTimeout","onPointerUp","clearTimeout","duration","onPointerMove","deltaY","deltaX","onPointerLeave","file","files","split","pop","accept"],"ignoreList":[],"sourceRoot":""}